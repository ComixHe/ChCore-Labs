### Question 2.1:

编译阶段：scripts/linker-aarch64.lds.in在.init段指定了bootloader的内存布局，.text, .data, .rodata, .bss等段指定了内核的内存布局。

运行阶段：在kernel/mm/mm.c中，mm_init函数初始化内存页相关部分，此时页面元数据和页面的内存布局被确定。

### Exercise 2.1:

见kernel/mm/buddy.c文件中的实现。

### Question 2.2：

性能：在内核态和用户态进行切换的时候，只要切换目标寄存器而不是刷新整个页表。

安全：不同的页表基地址采用不同的寄存器储存起到了一定的隔离效果，相对x86_64的高地址映射更安全。

### Question 2.3：

1.   页表中存放的地址是物理地址，后续需要对内存操作时可以转换成虚拟地址再操作。

2.   页表表项中存放的地址是虚拟地址。


### Question 2.4:

1.   当分页策略为单级页表时，采用常见的4k页表，需要$4GB \div 4KB = 1048576 $个页表，在64位系统下，一个页表项大小为8KB，则一共需要$1048576\times8KB\div1024=8192MB$。显然，这样做非常浪费空间，且有时并没有必要全部映射。所以降低开销的方法就是采用多级页表的分页策略。
2.   优点：采用多个基地址寄存器避免tlb刷新开销过于大，不同特权级的不同寄存器也在一定程度上保证了安全性。支持四级页表和常规的大页机制，使得内存管理和分配更加高效。

### Exercise 2.2：

具体实现参见kernel/mm/page_table.c文件。

### Question 2.5：

我认为需要，如果没有页表位上的属性来判断各种访问，那么内存中的越界访问等相关非法行为无法进行判断和处理，这样做有利于系统安全。同时有一些页表位，例如共享位、缓存位等等标志位还是很有必要的，因为这样能更好更全面的管理内存资源。

### Question 2.6：

1.   内核空间相较于其他空间来说活动更加频繁，此时使用大页可以减少TLB miss的次数，使得内核运行效率更高。内存管理相关空间要在boot阶段映射，依赖于内存管理模块的相关空间中的模块可以在内核启动后映射。
2.   在cpu访存时会对页表项中的标志位做合法性检查，非法内存访问会产生异常从而保护内核。

### Exercise 2.3：

具体实现参见kernel\mm\mm.c文件。
